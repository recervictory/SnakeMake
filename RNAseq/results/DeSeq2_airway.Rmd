---
title: "RNASeq Analysis"
author: "Victor Banerjee"
date: "2023-02-22"
output: html_document
---
### Install and import Library
```{r installer, message=FALSE, warning=TRUE, include=FALSE}
#BiocManager::install("DESeq2")
#BiocManager::install("edgeR")
#BiocManager::install("airway")

library(DESeq2)
library(airway)
library(ggplot2)
```

### Speed-up and parallelization thoughts
```{r, message=FALSE, warning=TRUE, include=FALSE}
#  BiocManager::install("BiocParallel")
library("BiocParallel")
register(MulticoreParam(4))
```


### The airway data
```{r}
data(airway)
# show the metadata
airway
airway$dex
airway$cell
```
```{r}
# First 10 transcripts
assay(airway, "counts")[1:10,]

```

### Pre-Processing
The main variable of interest is dex which takes on levels trt (treated) and untrt (untreated). The first level will be the reference level for this factor, so we use relevel() to set the untrt level as reference; this is much easier to interpret.
```{r}
airway$dex
airway$dex <- relevel(airway$dex, "untrt")
airway$dex
```

## DeSeq2 Analysis
```{r}
dds <- DESeqDataSet(airway, design = ~ cell + dex)
dds
```

## Pre-filtering:
Here we perform a minimal pre-filtering to keep only rows that have at least 10 reads total. Note that more strict filtering to increase power is automatically applied via independent filtering on the mean of normalized counts within the results function.
```{r}

dds <- dds [rowSums(counts(dds)) >= 50, ]
```

## Note on factor levels
By default, R will choose a reference level for factors based on alphabetical order. Then, if you never tell the DESeq2 functions which level you want to compare against (e.g. which level represents the control group), the comparisons will be based on the alphabetical order of the levels.

### Differential expression analysis
The standard differential expression analysis steps are wrapped into a single function, DESeq. The estimation steps performed by this function are described below, in the manual page for ?DESeq and in the Methods section of the DESeq2 publication (Love, Huber, and Anders 2014).

Results tables are generated using the function results, which extracts a results table with log2 fold changes, p values and adjusted p values. With no additional arguments to results, the log2 fold change and Wald test p value will be for the last variable in the design formula, and if this is a factor, the comparison will be the last level of this variable over the reference level (see previous note on factor levels). However, the order of the variables of the design do not matter so long as the user specifies the comparison to build a results table for, using the name or contrast arguments of results.

Details about the comparison are printed to the console, directly above the results table. The text, condition treated vs untreated, tells you that the estimates are of the logarithmic fold change log2(treated/untreated).
```{r}
dds <- DESeq(dds)
res <- results(dds, name="dex_trt_vs_untrt")
res
```
## Log fold change shrinkage for visualization and ranking
Shrinkage of effect size (LFC estimates) is useful for visualization and ranking of genes. To shrink the LFC, we pass the dds object to the function lfcShrink. Below we specify to use the apeglm method for effect size shrinkage (Zhu, Ibrahim, and Love 2018), which improves on the previous estimator.

We provide the dds object and the name or number of the coefficient we want to shrink, where the number refers to the order of the coefficient as it appears in resultsNames(dds).
```{r}
resultsNames(dds)
resLFC <- lfcShrink(dds, coef="dex_trt_vs_untrt", type="apeglm")
resLFC
```

# p-values and adjusted p-values
We can order our results table by the smallest p value, 
```{r}
resOrdered <- res[order(res$pvalue),]
summary(res)
```
How many adjusted p-values were less than 0.1?
```{r}
sum(res$padj < 0.1, na.rm=TRUE)
```
Note that the results function automatically performs independent filtering based on the mean of normalized counts for each gene, optimizing the number of genes which will have an adjusted p value below a given FDR cutoff, alpha. Independent filtering is further discussed below. By default the argument alpha is set to 0.1. If the adjusted p value cutoff will be a value other than 0.1, alpha should be set to that value:
```{r}
res05 <- results(dds, alpha=0.05)
summary(res05)
```
### Independent hypothesis weighting
A generalization of the idea of p value filtering is to weight hypotheses to optimize power. A Bioconductor package, IHW, is available that implements the method of Independent Hypothesis Weighting (Ignatiadis et al. 2016). Here we show the use of IHW for p value adjustment of DESeq2 results. For more details, please see the vignette of the IHW package. The IHW result object is stored in the metadata.
```{r eval=FALSE, include=FALSE}
# BiocManager::install("IHW")
library("IHW")
resIHW <- results(dds, filterFun=ihw)
summary(resIHW)
sum(resIHW$padj < 0.1, na.rm=TRUE)
metadata(resIHW)$ihwResult
```


## Exploring and exporting results
### Dispersion plot and fitting alternatives
Plotting the dispersion estimates is a useful diagnostic. The dispersion plot below is typical, with the final estimates shrunk from the gene-wise estimates towards the fitted estimates. Some gene-wise estimates are flagged as outliers and not shrunk towards the fitted value, (this outlier detection is described in the manual page for estimateDispersionsMAP). The amount of shrinkage can be more or less than seen here, depending on the sample size, the number of coefficients, the row mean and the variability of the gene-wise estimates.
```{r Dispersion_est_plot, fig.height=8, fig.width=8}
plotDispEsts(dds, main = "Dispersion Estimates Plot", 
             xlab = "Mean of Normalized Counts", 
             ylab = "Dispersion Estimates")
```






### Data quality assessment by sample clustering and visualization
Data quality assessment and quality control (i.e. the removal of insufficiently good data) are essential steps of any data analysis. These steps should typically be performed very early in the analysis of a new data set, preceding or in parallel to the differential expression testing.

We define the term quality as fitness for purpose. Our purpose is the detection of differentially expressed genes, and we are looking in particular for samples whose experimental treatment suffered from an anormality that renders the data points obtained from these particular samples detrimental to our purpose.

### Heatmap of the count matrix
To explore a count matrix, it is often instructive to look at it as a heatmap. Below we show how to produce such a heatmap for various transformations of the data.





```{r Heatmap_top_20_genes, fig.height=8, fig.width=6}
library("pheatmap")

# Select the top 20 most highly expressed genes
select <- order(rowMeans(counts(dds,normalized=TRUE)),
                decreasing=TRUE)[1:20]

# Extract the "dex" and "cell" metadata columns from the colData object and convert to a data frame
df <- as.data.frame(colData(dds)[,c("dex","cell")])

# Generate the heatmap plot using pheatmap, with options to turn off row clustering, show column annotations, 
# and use the "df" data frame as the column annotation data
pheatmap(assay(airway)[select,], cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df,
         main = "Heatmap of Top 20 Expressed Genes",
         xlab = "Samples")

```
### Heatmap of the sample-to-sample distances
Another use of the transformed data is sample clustering. Here, we apply the dist function to the transpose of the transformed count matrix to get sample-to-sample distances.
```{r heatmap}
vsd <- vst(dds, blind=FALSE)
head(vsd)
sampleDists <- dist(t(assay(vsd)))
```

A heatmap of this distance matrix gives us an overview over similarities and dissimilarities between samples. We have to provide a hierarchical clustering hc to the heatmap function based on the sample distances, or else the heatmap function would calculate a clustering based on the distances between the rows/columns of the distance matrix.
```{r}
library("RColorBrewer")  # Load the RColorBrewer package for color palettes

# Convert the sample distance matrix to a matrix and set the row names to a combination of "dex" and "cell" metadata columns
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$dex, vsd$cell, sep="-")

# Set the column names to NULL to prevent them from being displayed in the heatmap
colnames(sampleDistMatrix) <- NULL

# Create a color palette for the heatmap using the colorRampPalette and brewer.pal functions
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

# Generate the heatmap plot using pheatmap, with options to cluster rows and columns by sample distance and use the "colors" palette for the color scale
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors,
         main = "Sample Distance Heatmap",  # Add a title to the plot
         xlab = "Sample ID",  # Change the x-axis label to "Sample ID"
         ylab = "Sample ID")  # Change the y-axis label to "Sample ID"


```

### Principal component plot of the samples
Related to the distance matrix is the PCA plot, which shows the samples in the 2D plane spanned by their first two principal components. This type of plot is useful for visualizing the overall effect of experimental covariates and batch effects.
```{R, fig.height=5, fig.width=5}

plotPCA(vsd, intgroup=c("dex"))
```
```{r pca_plot, fig.height=5, fig.width=5}
pcaData <- plotPCA(vsd, intgroup=c("dex", "cell"), returnData=TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(PC1, PC2, color=dex, shape=cell)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed() +
  labs(title = "PCA Plot", 
       color = "Treatment",
       shape = "Cell Type")

```


### Annotating and exporting results
Our result table so far only contains the Ensembl gene IDs, but alternative gene names may be more informative for interpretation. Bioconductor’s annotation packages help with mapping various ID schemes to each other. We load the AnnotationDbi package and the annotation package org.Hs.eg.db:
This is the organism annotation package (“org”) for Homo sapiens (“Hs”), organized as an AnnotationDbi database package (“db”), using Entrez Gene IDs (“eg”) as primary key. To get a list of all available key types, use:
```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")

columns(org.Hs.eg.db)
```
We can use the mapIds function to add individual columns to our results table. We provide the row names of our results table as a key, and specify that keytype=ENSEMBL. The column argument tells the mapIds function which information we want, and the multiVals argument tells the function what to do if there are multiple possible values for a single input value. Here we ask to just give us back the first one that occurs in the database. To add the gene symbol and Entrez ID, we call mapIds twice.

```{r}
ens.str <- substr(rownames(res), 1, 15)
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=ens.str,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")
```
```{r}
res$ENSEMBL <- rownames(res)
resOrdered <- res[order(res$pvalue),]
head(resOrdered)
```
### MAplot
In DESeq2, the function plotMA shows the log2 fold changes attributable to a given variable over the mean of normalized counts for all the samples in the DESeqDataSet. Points will be colored red if the adjusted p value is less than 0.1. Points which fall out of the window are plotted as open triangles pointing either up or down.
```{r MA_plot, fig.height=10, fig.width=10}
ylim <- c(-6.5,6.5)
drawLines <- function() abline(h=c(-1.5,1.5),col="dodgerblue",lwd=2)
DESeq2::plotMA(resOrdered, ylim=ylim); drawLines()
```


```{r MA_ggplot, fig.height=10, fig.width=10}
#install.packages("ggpubr")
library(ggpubr)

# Add rectangle around labels
ggmaplot(resOrdered, main = expression("UnTreated vs Treated"),
   fdr = 0.05, fc = 2, size = 0.4,
   palette = c("#B31B21", "#1465AC", "darkgray"),
   genenames = as.vector(resOrdered$symbol),
   legend = "top", top = 20,
   font.label = c("bold", 11), label.rectangle = TRUE,
   font.legend = "bold",
   font.main = "bold",
   ggtheme = ggplot2::theme_minimal())
```
### Enahansed volacano
```{r enahansed_volacano, fig.height=10, fig.width=10}
library(EnhancedVolcano)
EnhancedVolcano(resOrdered, 
                lab = resOrdered$symbol, 
                x = 'log2FoldChange',
                y = 'pvalue',
                xlim = c(-11, 11),
                title = 'Airway DESeq2 results',
                subtitle = 'Differential expression',
                legendPosition = "top",
                col = c('grey30', 'forestgreen', 'royalblue', 'red2'),
                colAlpha = 0.9,
                )
```
### Gene clustering
In the sample distance heatmap made previously, the dendrogram at the side shows us a hierarchical clustering of the samples. Such a clustering can also be performed for the genes. Since the clustering is only relevant for genes that actually carry a signal, one usually would only cluster a subset of the most highly variable genes. Here, for demonstration, let us select the 20 genes with the highest variance across samples. We will work with the VST data.
```{r top_genes, fig.height=10, fig.width=6}
library("genefilter")
topVarGenes <- head(order(rowVars(assay(vsd)), decreasing = TRUE), 50)
mat  <- assay(vsd)[ topVarGenes, ]
mat  <- mat - rowMeans(mat)
ens.str <- substr(rownames(mat), 1, 15)
rownames(mat) <- mapIds(org.Hs.eg.db,
                     keys=ens.str,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")

anno <- as.data.frame(colData(vsd)[, c("cell","dex")])
pheatmap(mat, annotation_col = anno)
```

### Exporting results
A more sophisticated way for exporting results the Bioconductor package ReportingTools (Huntley et al. 2013). ReportingTools will automatically generate dynamic HTML documents, including links to external databases using gene identifiers and boxplots summarizing the normalized counts across groups. See the ReportingTools vignettes for full details. The simplest version of creating a dynamic ReportingTools report is performed with the following code:
```{r}

#BiocManager::install("ReportingTools")
library("ReportingTools")
resOrderedDF <- as.data.frame(resOrdered)[1:100, ]
write.csv(resOrderedDF, file = "results.csv")

htmlRep <- HTMLReport(shortName="report", title="My report",
                      reportDirectory="./report")

publish(resOrderedDF, htmlRep)
#url <- finish(htmlRep)
#browseURL(url)
```


### Saving The Files:
```{r}

write.table(res, file='results_airway.tsv', sep="\t", quote=FALSE, row.names=TRUE)
```


